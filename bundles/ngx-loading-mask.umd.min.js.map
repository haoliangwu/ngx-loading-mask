{
  "version": 3,
  "file": "ngx-loading-mask.umd.min.js",
  "sources": [
    "ng://ngx-loading-mask/src/app/loading-mask/config.ts",
    "ng://ngx-loading-mask/src/app/loading-mask/model/event.ts",
    "ng://ngx-loading-mask/src/app/loading-mask/loading-mask.service.ts",
    "ng://ngx-loading-mask/src/app/loading-mask/loading-mask.directive.ts",
    "ng://ngx-loading-mask/src/app/loading-mask/loading-snip.component.ts",
    "ng://ngx-loading-mask/src/app/loading-mask/loading-mask.interceptor.ts",
    "ng://ngx-loading-mask/src/app/loading-mask/loading-mask.module.ts"
  ],
  "sourcesContent": [
    "import { InjectionToken } from '@angular/core'\nimport { Config } from './model/config'\n\nexport const DEFAULT_CONFIG: Config = {\n  snippet: {\n    imgUrl: null,\n    size: 144\n  },\n  mask: {\n    bgColor: 'rgba(255, 255, 255, .7)'\n  },\n  clsMapping: {\n    mask: 'ngx-loading-mask',\n    snip: 'ngx-loading-snip'\n  },\n  debug: false\n}\n\nexport const LOADING_MASK_HEADER = 'X-Loading-Mask'\n\nexport const DEFAULT_MASK_GROUP = 'default_mask_group'\n\nexport const CONFIG = new InjectionToken<Config>('ngx.loadingMask.config')\n",
    "export enum LoadingStatus {\n  INIT = '__init__',\n  PENDING = 'pending',\n  DONE = 'done',\n  ERROR = 'error'\n}\n\nexport interface LoadingEvent {\n  id: string,\n  status: LoadingStatus,\n  data?: any\n}\n",
    "import { Injectable, Inject } from '@angular/core'\nimport { LoadingMaskGroupMap, LoadingMaskGroup } from './model/mask'\n\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject'\nimport { LoadingEvent, LoadingStatus } from './model/event'\nimport { Observable } from 'rxjs/Observable'\nimport { filter } from 'rxjs/operators'\nimport { Config } from './model/config'\nimport { CONFIG, DEFAULT_MASK_GROUP } from './config'\n\n@Injectable()\nexport class LoadingMaskService {\n  private isSnipPreload = false\n  private uuid = 1\n  private maskGroupMap: LoadingMaskGroupMap\n\n  private loadingEvent$ = new BehaviorSubject<LoadingEvent>({\n    id: '__init__',\n    status: LoadingStatus.INIT\n  })\n\n  constructor(\n    @Inject(CONFIG) private config: Config\n  ) {\n    this.bootstrap()\n  }\n\n  subscribe(groupName?: string): Observable<LoadingEvent> {\n    if (!!groupName) {\n      return this.loadingEvent$.pipe(\n        filter(e => e.id === groupName)\n      )\n    } else {\n      return this.loadingEvent$.asObservable()\n    }\n  }\n\n  /*\n   * register group instance\n   */\n  register(groupName: string = DEFAULT_MASK_GROUP, replace = false): LoadingMaskGroup {\n    if (groupName.length === 0) {\n      groupName = DEFAULT_MASK_GROUP\n    }\n\n    let group: LoadingMaskGroup\n\n    if (this.isDefaultGroup(groupName)) {\n      group = this.getGroup(groupName, true)\n    } else {\n      group = this.setGroup(groupName, replace)\n    }\n\n    return group\n  }\n\n  /*\n   * unregister group instance\n   */\n  unregister(groupName: string): void {\n    if (this.isDefaultGroup(groupName)) {\n      throw new Error('cannot unregister default loading mask group')\n    }\n\n    if (!this.maskGroupMap.has(groupName)) {\n      throw new Error('cannot unregister non-existed loading mask group')\n    }\n\n    const group = this.getGroup(groupName)\n\n    group.instances--\n\n    if (group.instances === 0) {\n      this.maskGroupMap.delete(groupName)\n    }\n  }\n\n  /*\n   * if groupName is default group name\n   */\n  isDefaultGroup(groupName: string): boolean {\n    return groupName === DEFAULT_MASK_GROUP\n  }\n\n  /*\n   * if group has been done status\n   */\n  isDoneGroup(group: LoadingMaskGroup): boolean {\n    return group.done === group.pending\n  }\n\n  /*\n   * get group instance of groupName\n   * if don't existed and safe = true, set new group instance with groupName and return it\n   */\n  getGroup(groupName: string, safe = false): LoadingMaskGroup {\n    if (this.maskGroupMap.has(groupName)) {\n      return this.maskGroupMap.get(groupName)\n    } else {\n      if (safe) {\n        return this.setGroup(groupName)\n      }\n    }\n  }\n\n  /*\n   * set group instance of groupName\n   * if replace = false, will return exited group instance with corresponding groupName\n   * otherwise, will replace current group instance with new one\n   */\n  setGroup(groupName: string, replace = false): LoadingMaskGroup {\n    let group: LoadingMaskGroup\n\n    if (!replace && this.maskGroupMap.has(groupName)) {\n      group = this.getGroup(groupName)\n    } else {\n      group = this.maskGroupFactory(groupName)\n      this.maskGroupMap.set(groupName, group)\n    }\n\n    group.instances++\n\n    return group\n  }\n\n  showGroup(groupName: string = DEFAULT_MASK_GROUP) {\n    this.loadingEvent$.next(this.loadingEventFactory(groupName, LoadingStatus.PENDING))\n  }\n\n  hideGroup(groupName: string = DEFAULT_MASK_GROUP) {\n    this.loadingEvent$.next(this.loadingEventFactory(groupName, LoadingStatus.DONE))\n  }\n\n  hideGroupError(groupName: string = DEFAULT_MASK_GROUP, error: any) {\n    this.loadingEvent$.next(this.loadingEventFactory(groupName, LoadingStatus.ERROR, error))\n  }\n\n  preloadImage() {\n    if (this.isSnipPreload) return\n\n    const { snippet: { imgUrl } } = this.config\n\n    console.group('starting preload snip image from:', imgUrl)\n    this.isSnipPreload = true\n\n    const img: HTMLImageElement = new Image()\n    img.src = imgUrl\n    img.onload = () => {\n      console.log('preloaded sucessfully')\n      console.groupEnd()\n      this.isSnipPreload = true\n    }\n\n    img.onerror = () => {\n      console.log('preloaded met some error')\n      console.groupEnd()\n      this.isSnipPreload = false\n    }\n  }\n\n  private bootstrap(): void {\n    this.maskGroupMap = new Map()\n    this.setGroup(DEFAULT_MASK_GROUP, true)\n  }\n\n  private loadingEventFactory(groupName: string, status: LoadingStatus, data?: any): LoadingEvent {\n    return {\n      id: groupName,\n      status,\n      data\n    }\n  }\n\n  private maskGroupFactory(groupName: string): LoadingMaskGroup {\n    return {\n      uuid: this.uuid++,\n      id: groupName,\n      pending: 0,\n      done: 0,\n      isError: false,\n      instances: 0\n    }\n  }\n}\n",
    "import { Directive, Input, ComponentFactoryResolver, ApplicationRef, Injector, Host, ElementRef, Inject, ContentChild, TemplateRef } from '@angular/core'\nimport { LoadingMaskService } from './loading-mask.service'\nimport { OnInit, OnDestroy } from '@angular/core/src/metadata/lifecycle_hooks'\nimport { Subscription } from 'rxjs/Subscription'\nimport { Observable } from 'rxjs/Observable'\nimport { LoadingEvent, LoadingStatus } from './model/event'\nimport { LoadingMaskGroup } from './model/mask'\n\nimport { ComponentPortal, DomPortalHost } from '@angular/cdk/portal'\nimport { LoadingSnipComponent } from './loading-snip.component'\nimport { catchError, tap, flatMap } from 'rxjs/operators'\nimport { of } from 'rxjs/observable/of'\nimport { empty } from 'rxjs/observable/empty'\nimport { Config } from './model/config'\nimport { CONFIG, DEFAULT_CONFIG } from './config'\nimport { logGroupStatus } from './utils/log'\n\n@Directive({\n  selector: '[ngxLoadingMask]',\n  exportAs: 'mask'\n})\nexport class LoadingMaskDirective implements OnInit, OnDestroy {\n  @Input() public ngxLoadingMask: string\n  public isDefault = false\n  @ContentChild('mask') public maskTplRef: TemplateRef<any>\n\n  private loadingEvent$: Observable<LoadingEvent>\n  private subscription: Subscription\n  private group: LoadingMaskGroup\n\n  private loadingSnipPortal: ComponentPortal<LoadingSnipComponent>\n  private portalHost: DomPortalHost\n  private portalHostEl: HTMLElement\n\n  constructor(\n    @Inject(CONFIG) private config: Config,\n    private service: LoadingMaskService,\n    private componentFactoryResolver: ComponentFactoryResolver,\n    private appRef: ApplicationRef,\n    private injector: Injector,\n    @Host() private el: ElementRef\n  ) { }\n\n  ngOnInit() {\n    this.group = this.service.register(this.ngxLoadingMask)\n\n    this.config = Object.assign(DEFAULT_CONFIG, this.config)\n\n    this.service.preloadImage()\n\n    const { id } = this.group\n\n    this.isDefault = this.service.isDefaultGroup(id)\n    this.loadingEvent$ = this.service.subscribe(id)\n\n    this.loadingSnipPortal = new ComponentPortal(LoadingSnipComponent)\n    this.portalHostEl = this.service.isDefaultGroup(id) ? document.body : this.el.nativeElement\n\n    this.portalHost = new DomPortalHost(\n      this.portalHostEl,\n      this.componentFactoryResolver,\n      this.appRef,\n      this.injector)\n\n    this.subscription = this.loadingEvent$.pipe(\n      flatMap(e => {\n        return of(e).pipe(\n          tap(t => this.handleEvent(t)),\n          catchError((err, source) => {\n            console.error(err)\n            return empty()\n          })\n        )\n      }))\n      .subscribe()\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe()\n  }\n\n  private handleEvent(e: LoadingEvent) {\n    switch (e.status) {\n      case LoadingStatus.PENDING:\n        this.group.pending++\n        if (this.group.isError) this.group.isError = false\n\n        if (this.config.debug) {\n          logGroupStatus(this.group, LoadingStatus.PENDING)\n        }\n\n        if (this.portalHost.hasAttached()) return\n        else this.reveal()\n\n        break\n      case LoadingStatus.DONE:\n        this.group.done++\n\n        if (this.config.debug) {\n          logGroupStatus(this.group, LoadingStatus.DONE)\n        }\n\n        if (this.service.isDoneGroup(this.group)) {\n          this.group.done = 0\n          this.group.pending = 0\n\n          this.hide()\n        }\n\n        break\n      case LoadingStatus.ERROR:\n        this.group.done = 0\n        this.group.pending = 0\n\n        this.group.isError = true\n\n        if (this.config.debug) {\n          logGroupStatus(this.group, LoadingStatus.ERROR)\n        }\n\n        this.hideError(e.data)\n\n        break\n    }\n  }\n\n  reveal() {\n    // TODO track https://github.com/angular/material2/issues/8628\n    // this.portalHost.attachComponentPortal(this.loadingSnipPortal)\n    this.portalHost.attach(this.loadingSnipPortal)\n  }\n\n  hide() {\n    this.portalHost.detach()\n  }\n\n  hideError(error: any) {\n    this.hide()\n\n    throw new Error(error)\n  }\n}\n",
    "import { Component, OnInit, Inject, ViewEncapsulation } from '@angular/core'\nimport { ClsMapping, Config } from './model/config'\nimport { CONFIG, DEFAULT_CONFIG } from './config'\nimport { LoadingMaskDirective } from './loading-mask.directive'\n\n@Component({\n  selector: 'ngx-loading-snip',\n  encapsulation: ViewEncapsulation.None,\n  template: `<div class=\"loading-mask-base\" [ngClass]=\"maskCls\" [ngStyle]=\"maskStyle\">\n  <div class=\"loading-snip-base\" [ngClass]=\"snipCls\">\n    <img *ngIf=\"!mask.maskTplRef\" [attr.src]=\"imgUrl\" [ngStyle]=\"snipStyle\"/>\n    <ng-container *ngIf=\"mask.maskTplRef\">\n        <ng-container *ngTemplateOutlet=\"mask.maskTplRef\">\n        </ng-container>\n      </ng-container>\n  </div>\n</div>\n`,\n  styles: [`.loading-mask-base {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  z-index: 99; }\n  .loading-mask-base.global {\n    position: fixed;\n    width: 100vw;\n    height: 100vh; }\n\n.loading-snip-base {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%); }\n`]\n})\nexport class LoadingSnipComponent implements OnInit {\n  private cls: ClsMapping\n\n  imgUrl: string\n  size: number\n  bgColor: string\n\n  get maskCls() {\n    return [this.cls.mask, this.mask.isDefault ? 'global' : '']\n  }\n\n  get maskStyle() {\n    return {\n      'background': this.bgColor\n    }\n  }\n\n  get snipCls() {\n    return this.cls.snip\n  }\n\n  get snipStyle() {\n    return {\n      'width.px': this.size,\n      'height.px': this.size\n    }\n  }\n\n  constructor(\n    @Inject(CONFIG) private config: Config,\n    public mask: LoadingMaskDirective\n  ) { }\n\n  ngOnInit() {\n    this.config = Object.assign(DEFAULT_CONFIG, this.config)\n\n    this.cls = this.config.clsMapping\n    this.imgUrl = this.config.snippet.imgUrl\n    this.size = this.config.snippet.size\n    this.bgColor = this.config.mask.bgColor\n  }\n}\n",
    "import { Injectable } from '@angular/core'\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse, HttpErrorResponse } from '@angular/common/http'\n\nimport { Observable } from 'rxjs/Observable'\nimport { LoadingMaskService } from './loading-mask.service'\nimport { tap } from 'rxjs/operators'\nimport { LOADING_MASK_HEADER } from './config'\n\n@Injectable()\nexport class LoadingMaskInterceptor implements HttpInterceptor {\n  constructor(\n    private service: LoadingMaskService\n  ) { }\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.headers.has(LOADING_MASK_HEADER)) {\n      // TODO use custom header as custom metadata, maybe deprecated in the future\n      // refer to https://github.com/angular/angular/issues/18155\n      const groupName = req.headers.get(LOADING_MASK_HEADER)\n\n      req = req.clone({\n        headers: req.headers.delete(LOADING_MASK_HEADER)\n      })\n\n      this.service.showGroup(groupName)\n\n      return next.handle(req).pipe(\n        tap(event => {\n          if (event instanceof HttpResponse) {\n            // TODO hide mask here\n            this.service.hideGroup(groupName)\n          }\n        }, error => {\n          if (error instanceof HttpErrorResponse) {\n            // TODO hide mask with error here\n            this.service.hideGroupError(groupName, error)\n          }\n        })\n      )\n    } else {\n      return next.handle(req)\n    }\n  }\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core'\nimport { CommonModule } from '@angular/common'\nimport { LoadingSnipComponent } from './loading-snip.component'\nimport { LoadingMaskDirective } from './loading-mask.directive'\nimport { Config } from './model/config'\nimport { CONFIG } from './config'\nimport { LoadingMaskService } from './loading-mask.service'\nimport { HTTP_INTERCEPTORS } from '@angular/common/http'\nimport { LoadingMaskInterceptor } from './loading-mask.interceptor'\n\n@NgModule({\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    LoadingSnipComponent,\n    LoadingMaskDirective\n  ],\n  exports: [\n    LoadingMaskDirective\n  ],\n  entryComponents: [\n    LoadingSnipComponent\n  ]\n})\nexport class LoadingMaskModule {\n  static forRoot(config: Config): ModuleWithProviders {\n    return {\n      ngModule: LoadingMaskModule,\n      providers: [\n        LoadingMaskService,\n        {\n          useValue: config,\n          provide: CONFIG\n        },\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: LoadingMaskInterceptor,\n          multi: true,\n        }\n      ]\n    }\n  }\n}\n"
  ],
  "names": [
    "snippet",
    "imgUrl",
    "size",
    "mask",
    "bgColor",
    "clsMapping",
    "snip",
    "debug",
    "LOADING_MASK_HEADER",
    "DEFAULT_MASK_GROUP",
    "CONFIG",
    "InjectionToken",
    "DONE",
    "ERROR",
    "this",
    "uuid",
    "loadingEvent$",
    "BehaviorSubject$1",
    "id",
    "status",
    "LoadingStatus",
    "INIT",
    "bootstrap",
    "asObservable",
    "groupName",
    "length",
    "isDefaultGroup",
    "getGroup",
    "setGroup",
    "replace",
    "Error",
    "maskGroupMap",
    "has",
    "group",
    "instances",
    "delete",
    "done",
    "pending",
    "safe",
    "get",
    "LoadingMaskService",
    "prototype",
    "maskGroupFactory",
    "set",
    "showGroup",
    "hideGroup",
    "preloadImage",
    "_this",
    "isSnipPreload",
    "config",
    "console",
    "img",
    "Image",
    "src",
    "onload",
    "log",
    "groupEnd",
    "onerror",
    "loadingEventFactory",
    "data",
    "LoadingMaskDirective",
    "service",
    "componentFactoryResolver",
    "appRef",
    "injector",
    "el",
    "ngOnInit",
    "register",
    "ngxLoadingMask",
    "Object",
    "assign",
    "DEFAULT_CONFIG",
    "isDefault",
    "subscribe",
    "loadingSnipPortal",
    "ComponentPortal",
    "LoadingSnipComponent",
    "portalHostEl",
    "document",
    "body",
    "nativeElement",
    "portalHost",
    "DomPortalHost",
    "subscription",
    "pipe",
    "flatMap",
    "e",
    "of$1",
    "tap",
    "t",
    "handleEvent",
    "catchError",
    "err",
    "source",
    "error",
    "PENDING",
    "isError",
    "logGroupStatus",
    "hasAttached",
    "reveal",
    "isDoneGroup",
    "hide",
    "attach",
    "selector",
    "exportAs",
    "ctorParameters",
    "type",
    "ComponentFactoryResolver",
    "ApplicationRef",
    "defineProperty",
    "cls",
    "enumerable",
    "configurable",
    "width.px",
    "height.px",
    "req",
    "headers",
    "next",
    "handle",
    "event",
    "HttpResponse",
    "HttpErrorResponse",
    "hideGroupError",
    "groupName_1",
    "LoadingMaskInterceptor",
    "decorators",
    "Injectable",
    "ngModule",
    "LoadingMaskModule",
    "provide",
    "HTTP_INTERCEPTORS",
    "useClass",
    "multi",
    "NgModule",
    "args",
    "imports",
    "CommonModule",
    "exports",
    "entryComponents"
  ],
  "mappings": "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"
}
